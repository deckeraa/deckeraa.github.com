<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>I/Octopus</title>
  <link href="http://deckeraa.github.comindex.xml" rel="self" />
  <link href="http://deckeraa.github.com"/>
  <updated>Lisp error in nil: (wrong-type-argument integerp nil)</updated>
  <id>http://deckeraa.github.comindex.xml</id>
  <entry><title type="html">State Squid and I/Octopus</title><author><name>nil</name></author><link href="http://deckeraa.github.com/ioctopus/2012/09/13_state-squid-and-ioctopus.html"/><updated>2012-09-13T15:23:00Z</updated><published>2012-09-13T15:23:00Z</published><id>ioctopus/2012/09/13_state-squid-and-ioctopus.html</id><category scheme="/tags/functional-programming.html" term="Functional Programming" label="Functional Programming"/><category scheme="/tags/uml.html" term="UML" label="UML"/><category scheme="/tags/state.html" term="State" label="State"/><content type="html">&lt;p class="verse"&gt;
Once upon a time, in a land so fine,&lt;br/&gt;
where analysis happened all the time,&lt;br/&gt;
lived a happy little class family.&lt;br/&gt;
Yes, it was in the land of OO, where lines&lt;br/&gt;
and boxes and use case scenarios&lt;br/&gt;
frolic playfully in the street and all&lt;br/&gt;
the happy classes live together with&lt;br/&gt;
minimal coupling and high cohesion.&lt;br/&gt;
&lt;br/&gt;
Twas dusk one night at the coding class house,&lt;br/&gt;
where lived a family whose existence was due&lt;br/&gt;
to an assignment from a programming class.&lt;br/&gt;
Twas the RPN family of who&lt;br/&gt;
members were Susie Stack, sibling Quentin Queue,&lt;br/&gt;
RPNEval and Driver Class too.&lt;br/&gt;
Daddy Driver Class tucked them into bed&lt;br/&gt;
along with the state from their objects, he said.&lt;br/&gt;
Scary stories of high coupling he read,&lt;br/&gt;
but he assured them that all those bugs were long dead.&lt;br/&gt;
&lt;br/&gt;
Those bugs were before we had UML,&lt;br/&gt;
now we have OO and life is just swell.&lt;br/&gt;
With those words he bid them all a good night,&lt;br/&gt;
he bid them sweet dreams and turned off the light.&lt;br/&gt;
He thought to himself, as he went to his room,&lt;br/&gt;
Their state is encapsulated, all that&lt;br/&gt;
talk from functional programmers, of doom&lt;br/&gt;
and despair from state was lame and old hat.&lt;br/&gt;
He had it all taken care of, put in each class,&lt;br/&gt;
the lambda and OO schools had reached an impasse.&lt;br/&gt;
&lt;br/&gt;
But all through the night he had quite a fright,&lt;br/&gt;
unspeakable horrors passing through his mind's sight.&lt;br/&gt;
He dreamt of a kraken, no, just a huge squid,&lt;br/&gt;
that just stood and stared as he wondered what it did.&lt;br/&gt;
It's cavernous eyes peered deep into his soul,&lt;br/&gt;
This must be a prank, just a functional troll.&lt;br/&gt;
But there its singular figure remained,&lt;br/&gt;
on the UML of his soul it was firmly engrained.&lt;br/&gt;
Its tentacles were just lines, his face a mere shape,&lt;br/&gt;
But the diagram of his family it threatened to reshape.&lt;br/&gt;
&lt;br/&gt;
Rebellion against father, but just in his dream,&lt;br/&gt;
for RPNEval was drinking from the forbidden stream.&lt;br/&gt;
That ethereal stream that is called I/O,&lt;br/&gt;
whose state at runtime, nobody knows.&lt;br/&gt;
The paternal class cursed in frustration, no fear he could quell,&lt;br/&gt;
he thought he had had it all planned out so well.&lt;br/&gt;
But his model was naive, much too simple to be good,&lt;br/&gt;
he hadn't modeled the state of the &lt;i&gt;whole&lt;/i&gt; program like he should.&lt;br/&gt;
But now complexity, and inter-dependency too,&lt;br/&gt;
clamored around his program, like the monkeys at a zoo.&lt;br/&gt;
&lt;br/&gt;
Now there is a moral to this story, something just for you,&lt;br/&gt;
model &lt;i&gt;all&lt;/i&gt; the state in your program, or this too you will rue.&lt;br/&gt;
&lt;/p&gt;




</content></entry><entry><title type="html">Style Guidelines Revisited</title><author><name>nil</name></author><link href="http://deckeraa.github.com/ioctopus/2012/09/10_style-guidelines-revisited.html"/><updated>2012-09-10T03:25:00Z</updated><published>2012-09-10T03:25:00Z</published><id>ioctopus/2012/09/10_style-guidelines-revisited.html</id><category scheme="/tags/style.html" term="style" label="style"/><content type="html">&lt;p&gt;
  Coding style guidelines are great.
  They keep code looking consistent and can improve readability.
  As a result, many quality, widely-accepted coding styles exist
  &amp;ndash; K&amp;amp;R, GNU, Whitesmith are a few examples &amp;ndash; and are already
  loaded into IDE's such as Emacs or NetBeans. 
  This makes me wonder: Why do certain universities insist
  on creating their own style guidelines?
&lt;/p&gt;
&lt;p&gt;
  I was recently reading through the "programming ground rules" of a course
  at a certain university, which will remain unnamed.
  For context, this course uses C++ as the main language for the course.
  While many of the guidelines are good ideas and common sense,
  I came across some interesting rules.
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"Use the // comment style."
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  "Only use the &lt;code&gt;/* */&lt;/code&gt; comment style to
  temporarily comment out chunks of your program for testing and debugging." 
    I must admit I was a little confused by this one.
    Comments compile out.
    Additionally, all the editors I know of 
    are able to deal with both commenting styles.
    I just can't see how this affects readability.
&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;i&gt;Every&lt;/i&gt; function needs a doc banner.
    Even getters, setters, and the following function.



&lt;pre class="src src-cpp"&gt;&lt;span style="color: #f0dfaf; font-weight: bold;"&gt;class&lt;/span&gt; &lt;span style="color: #8cd0d3;"&gt;Stack&lt;/span&gt;
{
&lt;span style="color: #f0dfaf; font-weight: bold;"&gt;public&lt;/span&gt;:
   &lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;-----------------------------------&lt;/span&gt;
   &lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;Returns true if the stack is empty.&lt;/span&gt;
   &lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;-----------------------------------&lt;/span&gt;
   &lt;span style="color: #8cd0d3;"&gt;bool&lt;/span&gt; &lt;span style="color: #8cd0d3;"&gt;isEmpty&lt;/span&gt;() { &lt;span style="color: #7f9f7f;"&gt;/* &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;. . . */&lt;/span&gt; }
   &lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;...&lt;/span&gt;
};
&lt;/pre&gt;

&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;
  Thankfully, a few rules from previous courses were noticeably absent.
  Arguments no longer must be labeled in a 
  comment block as "in, out, or in/out".
  Do I have a problem with such labels?
  No, but when they are unnecessary they tend to &lt;i&gt;reduce&lt;/i&gt; the readability
  of the comments. 
  Take the following two functions for example.
  Yes, the function is deliberately simplified, but how much of your C++ code consists
  of such functions?
&lt;/p&gt;



&lt;pre class="src src-cpp"&gt;&lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;isOutOfBounds( int x, int y)&lt;/span&gt;
&lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;Returns true if the coordinates are in bounds.&lt;/span&gt;
&lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;Returns false otherwise.&lt;/span&gt;
&lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;ARGS: IN, IN&lt;/span&gt;
&lt;span style="color: #8cd0d3;"&gt;bool&lt;/span&gt; &lt;span style="color: #8cd0d3;"&gt;isOutOfBounds&lt;/span&gt;( &lt;span style="color: #8cd0d3;"&gt;int&lt;/span&gt; &lt;span style="color: #dfaf8f;"&gt;x&lt;/span&gt;, &lt;span style="color: #8cd0d3;"&gt;int&lt;/span&gt; &lt;span style="color: #dfaf8f;"&gt;y&lt;/span&gt; );
&lt;/pre&gt;


&lt;p&gt;
  or
&lt;/p&gt;



&lt;pre class="src src-cpp"&gt;&lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;Checks to see if the given coordinates are in bounds of the window.&lt;/span&gt;
&lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;Note that x and y are expressed in screen coordinates.&lt;/span&gt;
&lt;span style="color: #8cd0d3;"&gt;bool&lt;/span&gt; &lt;span style="color: #8cd0d3;"&gt;isOutOfBounds&lt;/span&gt;( &lt;span style="color: #8cd0d3;"&gt;int&lt;/span&gt; &lt;span style="color: #dfaf8f;"&gt;x&lt;/span&gt;, &lt;span style="color: #8cd0d3;"&gt;int&lt;/span&gt; &lt;span style="color: #dfaf8f;"&gt;y&lt;/span&gt; );
&lt;/pre&gt;


&lt;p&gt;
  The second declaration, though not rigidly formatted, provides far more
  information than the first.
  Also note this use of upper-case to convey that 1960's COBOL kind of feeling.
&lt;/p&gt;
&lt;p&gt;
  Also gone from the rules is the "30-line function limit", where points
  would be taken off for any function longer than 30 lines.
  While written to encourage modular design, the rule also encourages
  "code golf", where esoteric programming constructs and obscure evaluation
  rules help to fit the function inside of the line limit.
&lt;/p&gt;
&lt;p&gt;
  Take the following code snippets. Do they do the same thing?
&lt;/p&gt;



&lt;pre class="src src-cpp"&gt;&lt;span style="color: #8cd0d3;"&gt;void&lt;/span&gt; &lt;span style="color: #8cd0d3;"&gt;push&lt;/span&gt;( &lt;span style="color: #8cd0d3;"&gt;float&lt;/span&gt; &lt;span style="color: #dfaf8f;"&gt;obj_to_push&lt;/span&gt; )
{
   stack_data[current_index++] = obj_to_push;
}

&lt;span style="color: #7f9f7f;"&gt;// &lt;/span&gt;&lt;span style="color: #7f9f7f;"&gt;or&lt;/span&gt;

&lt;span style="color: #8cd0d3;"&gt;void&lt;/span&gt; &lt;span style="color: #8cd0d3;"&gt;push&lt;/span&gt;( &lt;span style="color: #8cd0d3;"&gt;float&lt;/span&gt; &lt;span style="color: #dfaf8f;"&gt;obj_to_push&lt;/span&gt; )
{
   current_index++;
   stack_data[current_index] = obj_to_push;
}

&lt;/pre&gt;


&lt;p&gt;  
  They do not do the same thing.
  The post-fix increment operator is evaluated &lt;i&gt;after&lt;/i&gt; the assignment operator.
  Encouraging code golf with line limits encourages language constructs that,
  while clever and loved by language lawyers, 
  are a pitfall for the creation of bugs.
&lt;/p&gt;
&lt;p&gt;
  Why then are programs graded according to criteria that at times are
  only tangentially related to good programming and at other times are
  actually opposed to proper coding?
  It would seem that the university system feels a need to conform
  programming into the standardized testing/grading paradigm currently
  embraced by many educational institutions, but has failed to quantify
  good programming practices.
&lt;/p&gt;
&lt;p&gt;
  How then, do we teach proper coding to students still struggling
  to master even the simplest aspects of programming such as language syntax?
  To be honest, I do not have an answer, and it would be preposterous if I
  purported to be qualified to propose proper pedagogical procedures.
  One thing I have noticed, however, is the inordinate amount of time spent
  learning language-specific constructs ( where the semi-colon goes )
  in courses that advertise themselves
  as being about things such as "data structures".
&lt;/p&gt;
&lt;p&gt;
  Perhaps the way to go is to use a language with little syntax such as
  Scheme.
  Hal Abelson and Gerald Jay Sussman employed such a method in their
  book &lt;a href="http://mitpress.mit.edu/sicp/"&gt;Structure and Interpretation of Computer Programs&lt;/a&gt; and their MIT course
  by the same name ( video lectures can be found &lt;a href="http://archive.org/details/mit_ocw_sicp"&gt;here&lt;/a&gt;).
  Roughly one lecture covered the syntax of Scheme, rather than half of 
  a semester using, say, Java ( as an aside, I would have to posit that
  Java's object reference system cannot be properly understood without
  first understanding the idea of pointers in a language such as C).
&lt;/p&gt;
</content></entry>
</feed>
